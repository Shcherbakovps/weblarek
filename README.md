# Проектная работа "Веб-ларек"

Стек: HTML, SCSS, TS, Webpack

Структура проекта:
- src/ — исходные файлы проекта
- src/components/ — папка с JS компонентами
- src/components/base/ — папка с базовым кодом

Важные файлы:
- index.html — HTML-файл главной страницы
- src/types/index.ts — файл с типами
- src/main.ts — точка входа приложения
- src/scss/styles.scss — корневой файл стилей
- src/utils/constants.ts — файл с константами
- src/utils/utils.ts — файл с утилитами

## Установка и запуск
Для установки и запуска проекта необходимо выполнить команды

```
npm install
npm run start
```

или

```
yarn
yarn start
```
## Сборка


```
npm run build
```

или

```
yarn build
```

## Данные, которые будут использоваться в приложении и классах
### Интерфейсы
В приложении будут задействованы следующие интерфейсы данных:
```ts
//Товар
interface IProduct {
  id: string;            //ID-номер товара
  description: string;   //Описание товара
  image: string;         //Ссылка на изображение
  title: string;         //Название
  category: string;      //Категория товара
  price: number | null;  //Цена товара
}

//Покупатель
interface IBuyer {
  payment: TPayment;     //тип оплаты
  email: string;         //адрес эл.почты
  phone: string;         //телефон
  address: string;       //адрес доставки
}
```
### Модели данных
В приложении задействованы три модели данных: каталог товаров, корзина, покупатель.
У каждой модели своя зона ответственности. 

#### Каталог товаров
Представляет собой список всех товаров на главной странице. Показывает выбранный товар.
Св-ва: 
-Хранит массив всех товаров;
-Хранит товар, выбранный для подробного отображения.
Методы: 
-сохранения массива товаров полученного в параметрах метода;
-получение массива товаров из модели;
-получение одного товара по его id;
-сохранения товара для подробного отображения;
-получение товара для подробного отображения.
```ts
class Catalog {
  private products: IProduct[] = [];
  private selectedProduct: IProduct | null = null;

  setProducts(products: IProduct[]): void {
    this.products = products;
  }

  getProducts(): IProduct[] {
    return this.products;
  }

  getProductById(id: string): IProduct | undefined {
    for (let i = 0; i < this.products.length; i++) {
      const product = this.products[i];
      if (product.id === id) {
        return product;
      }
    }
    return undefined; 
  }

  setSelectedProduct(product: IProduct): void {
    this.selectedProduct = product;
  }

  getSelectedProduct(): IProduct | null {
    return this.selectedProduct;
  }
}
```
#### Корзина
Хранит товары, которые покупатель выбрал для покупки
Св-ва:
-хранит массив товаров, которые добавил в корзину покупатель.
Методы:
-получение массива товаров, которые находятся в корзине;
-добавление товара, который был получен в параметре в массив корзины;
-удаление товара, полученного в параметре из массива корзины;
-очистка корзины;
-получение стоимости всех товаров в корзине;
-получение количества товаров в корзине;
-проверка наличия товара в корзине по его id, полученному в параметр метода. 
```ts
class Cart {
  private items: IProduct[] = [];
  
  //узнаем, что лежит в корзине
  getItems(): IProduct[] {
    return this.items;
  }

  //кладем товар в корзину
  addItem(product: IProduct): void {
    this.items.push(product);
  }

  //удаляем товар
  removeItem(id: string): void {
    this.items = this.items.filter(function(item) {
      return item.id !== id;
    });
  }

  //чистим массив внутри корзины
  clear(): void {
    this.items = [];
  }

  //cумма товаров в корзине
  getTotalPrice(): number {
    let total = 0;
    for (let i = 0; i < this.items.length; i++) {
        const product = this.items[i];
        const price = product.price ?? 0;
        total = total + price;
    }
    return total;
  }
  
  //узнаем количество товаров в корзине
  getItemCount(): number {
    return this.items.length;
  }

  //есть ли в корзине данный товар
  hasItem(id: string): boolean {
    return this.items.some(function(item) {
      return item.id === id;
    });
  }
}
```
#### Покупатель
Хранит данные о покупатели, которые нужны для последующего оформления заказа.
Св-ва:
-вид оплаты;
-адрес;
-телефон;
-e-mail. 
Методы: 
-сохранение данных в модели. Один общий метод или отдельные методы для каждого поля;
-получение всех данных покупателя;
-очистка данных покупателя;
-валидация данных.
```ts
class Buyer {
  private payment: TPayment | null = null;
  private address: string = '';
  private phone: string = '';
  private email: string = '';

  setBuyerData(data: IBuyer): void {
    this.payment = data.payment;
    this.address = data.address;
    this.phone = data.phone;
    this.email = data.email;
  }

  getBuyerData(): IBuyer {
    return {
      payment: this.payment as TPayment,
      address: this.address,
      phone: this.phone,
      email: this.email,
    };
  }

  clear(): void {
    this.payment = null;
    this.address = '';
    this.phone = '';
    this.email = '';
  }

  validate(): boolean {
    return Boolean(this.payment && this.address && this.phone && this.email);
  }
}
```

## Слой коммуникации
Для взаимодействия с сервером используем класс 'ShopAPI', который отвечает за обмен данными приложения и сервера "Веб-ларёк".
Ф-ии класса 'ShopAPI': 
- получение массива карточек товара с помощью 'GET / product';
- отправка заказа (выбранные товары и данные покупателя) на сервер с помощью 'POST /order/'.
Класс использует слудеющую композицию: в конструктор передается объект 'Api', реализованный в стартовом ките.
Методы класса: 
- 'getProducts()' - получить каталог карточек товара с сервера;
- 'createOrder(data: IOrderRequest)' - отправляет данные заказа и возвращает ответ сервера.


# Интернет-магазин «Web-Larёk»
«Web-Larёk» — это интернет-магазин с товарами для веб-разработчиков, где пользователи могут просматривать товары, добавлять их в корзину и оформлять заказы. Сайт предоставляет удобный интерфейс с модальными окнами для просмотра деталей товаров, управления корзиной и выбора способа оплаты, обеспечивая полный цикл покупки с отправкой заказов на сервер.

## Архитектура приложения

Код приложения разделен на слои согласно парадигме MVP (Model-View-Presenter), которая обеспечивает четкое разделение ответственности между классами слоев Model и View. Каждый слой несет свой смысл и ответственность:

Model - слой данных, отвечает за хранение и изменение данных.  
View - слой представления, отвечает за отображение данных на странице.  
Presenter - презентер содержит основную логику приложения и  отвечает за связь представления и данных.

Взаимодействие между классами обеспечивается использованием событийно-ориентированного подхода. Модели и Представления генерируют события при изменении данных или взаимодействии пользователя с приложением, а Презентер обрабатывает эти события используя методы как Моделей, так и Представлений.

### Событийная модель приложения
Для взаимодействия между слоями приложения (Model, View и Presenter) используется событийная модель на основе класса EventEmitter.
Она позволяет разделить ответственность между компонентами и сделать код модульным и расширяемым.
Каждый компонент представления (View) не изменяет данные напрямую, а эмитит события при действиях пользователя — эти события перехватываются презентером, который уже обращается к нужной модели.
Основные события:

#### Событие card:select
Местонахождение: компонент CardCatalogView.
Пользователь кликает на карточку товара в каталоге.
Презентер получает id товара и открывает модальное окно с детальной карточкой.

#### Событие basket:add 
Местонахождение: компонент CardPreviewView.
Пользователь нажимает кнопку «Добавить в корзину».
Презентер добавляет товар в корзину и обновляет счётчик.

#### Событие basket:remove
Местонахождение: компонент CardBasketView.
Пользователь удаляет товар из корзины.
Презентер обновляет список товаров и пересчитывает общую сумму.

#### Событие basket:open 
Местонахождение: компонент Header.
Пользователь открывает корзину кликом по соответствующему значку в шапке страницы.
Презентер открывает модальное окно с компонентом BasketView.

#### Событие order:open 
Местонахождение: компонент BasketView.
Пользователь нажимает кнопку «Оформить заказ».
Презентер открывает форму оформления (OrderView).

#### Событие order:submit
Местонахождение: компонент OrderView.
Пользователь отправляет форму оформления заказа.
Презентер сохраняет данные покупателя и открывает следующую форму.

#### Событие contacts:submit 
Местонахождение: компонент ContactView.
Пользователь отправляет контактные данные (email и телефон).
Презентер формирует заказ и отправляет его на сервер.

#### Событие order:success 
Местонахождение: компонент SuccessView.
Заказ успешно оформлен.
Презентер очищает корзину и закрывает модальное окно.

#### Событие form:validate 
Местонахождение: компонент OrderView или ContactView.
Проверяется корректность заполнения формы.
Презентер активирует или деактивирует кнопку «Продолжить».

### Базовый код
#### Класс Component
Является базовым классом для всех компонентов интерфейса.
Класс является дженериком и принимает в переменной `T` тип данных, которые могут быть переданы в метод `render` для отображения.

Конструктор:  
`constructor(container: HTMLElement)` - принимает ссылку на DOM элемент за отображение, которого он отвечает.

Поля класса:  
`container: HTMLElement` - поле для хранения корневого DOM элемента компонента.

Методы класса:  
`render(data?: Partial<T>): HTMLElement` - Главный метод класса. Он принимает данные, которые необходимо отобразить в интерфейсе, записывает эти данные в поля класса и возвращает ссылку на DOM-элемент. Предполагается, что в классах, которые будут наследоваться от `Component` будут реализованы сеттеры для полей с данными, которые будут вызываться в момент вызова `render` и записывать данные в необходимые DOM элементы.  
`setImage(element: HTMLImageElement, src: string, alt?: string): void` - утилитарный метод для модификации DOM-элементов `<img>`

#### Класс Api
Содержит в себе базовую логику отправки запросов.

Конструктор:  
`constructor(baseUrl: string, options: RequestInit = {})` - В конструктор передается базовый адрес сервера и опциональный объект с заголовками запросов.

Поля класса:  
`baseUrl: string` - базовый адрес сервера  
`options: RequestInit` - объект с заголовками, которые будут использованы для запросов.

Методы:  
`get(uri: string): Promise<object>` - выполняет GET запрос на переданный в параметрах ендпоинт и возвращает промис с объектом, которым ответил сервер  
`post(uri: string, data: object, method: ApiPostMethods = 'POST'): Promise<object>` - принимает объект с данными, которые будут переданы в JSON в теле запроса, и отправляет эти данные на ендпоинт переданный как параметр при вызове метода. По умолчанию выполняется `POST` запрос, но метод запроса может быть переопределен заданием третьего параметра при вызове.  
`handleResponse(response: Response): Promise<object>` - защищенный метод проверяющий ответ сервера на корректность и возвращающий объект с данными полученный от сервера или отклоненный промис, в случае некорректных данных.

#### Класс EventEmitter
Брокер событий реализует паттерн "Наблюдатель", позволяющий отправлять события и подписываться на события, происходящие в системе. Класс используется для связи слоя данных и представления.

Конструктор класса не принимает параметров.

Поля класса:  
`_events: Map<string | RegExp, Set<Function>>)` -  хранит коллекцию подписок на события. Ключи коллекции - названия событий или регулярное выражение, значения - коллекция функций обработчиков, которые будут вызваны при срабатывании события.

Методы класса:  
`on<T extends object>(event: EventName, callback: (data: T) => void): void` - подписка на событие, принимает название события и функцию обработчик.  
`emit<T extends object>(event: string, data?: T): void` - инициализация события. При вызове события в метод передается название события и объект с данными, который будет использован как аргумент для вызова обработчика.  
`trigger<T extends object>(event: string, context?: Partial<T>): (data: T) => void` - возвращает функцию, при вызове которой инициализируется требуемое в параметрах событие с передачей в него данных из второго параметра.


### Слой представления (View компоненты)
Данный слой отвечает за отрисовку элементов интерфейса. 
#### Компонент CardCatalogView
Зачем нужен: отображает карточку товара в списке каталога.
Наследник класса Component<IProduct> 
Constructor: (container: HTMLElement, events: IEvents)
Методы: 
set title(value: string) - установить заголовок;
set image(value: string) - установить картинку;
set price(value: number | null) - установить цену;
set category(value: string) - установить категорию.

#### Компонент GalleryView
Зачем нужен: отображает карточки в галерее.
Наследует класс Component<{cards: CardCatalogView[]}>
Методы: 
render(data: {cards: CardCatalogView[]}) - принимает массив с карточками товара и отрисовывает их в галерее;
clear() - очистка галереи.

#### Компонент ModalWindowView
Контейнер модального окна
наследник класса Component<{}>
Методы: open() и close()

#### Компонент CardPreviewView
Подробная карточка товара при открывании в модальном окне (#card-preview).
Наследник класса Component<IProduct>. 
Методы:
set title(value: string) - установить заголовок;
set image(value: string) - установить картинку;
set price(value: number | null) - установить цену;
set description() - установить описание;
onAddtoCart(handler: () => void) - добавить слушателя на кнопку "Добавить в корзину".

#### Компонент CardBasketView
Карточка товара в виде строки внутри корзины (#card-basket).
Наследник класса Component<IProduct>. 
Методы:
set title(value: string) - установить заголовок;
set price(value: number | null) - установить цену;
set index(value: number) - порядковый номер в корзине;
onDelete(handler: () => void) - обработчик для кнопки "Удалить".

#### Компонент BasketView
Отображает содержимое корзины и общую сумму заказа.
Наследник класса Component<{}>.
Constructor: (container: HTMLElement)
Методы:
renderCards(cards: CardBasketView[]) — отрисовать карточки товаров, лежащие в корзине;
setTotalPrice(value: number) — установить общую сумму заказа;
onOrder(handler: () => void) — обработчик нажатия на кнопку “Оформить заказ”;
render() — вернуть контейнер компонента.

#### Компонент ContactView
Форма для ввода контактных данных покупателя (телефон и email).
Наследник класса Component<{}>.
Constructor: (container: HTMLElement)
Методы:
onSubmit(handler: (data: Partial<IBuyer>) => void) — установить обработчик отправки формы;
setErrors(text: string) — отобразить сообщение об ошибке;
render() — вернуть контейнер компонента.
Особенности:
Выполняет простую валидацию — кнопка “Продолжить” активируется, если заполнено хотя бы одно поле (email или телефон).

#### Компонент OrderView
Форма оформления заказа — ввод адреса и выбор способа оплаты.
Наследник класса Component<{}>.
Constructor: (container: HTMLElement)
Методы:
onSubmit(handler: (data: IBuyer) => void) — установить обработчик отправки формы;
fill(data: Partial<IBuyer>) — заполнить форму текущими значениями покупателя;
setErrors(text: string) — отобразить сообщение об ошибке;
render() — вернуть контейнер компонента.
Особенности:
Реализует выбор способа оплаты (наличные или карта) с применением CSS-модификатора is-active к выбранной кнопке. Проверяет корректность заполнения формы перед отправкой.

#### Компонент SuccessView
Окно, которые выводит инфо об успешном оформлении заказа.
Наследник класса Component<{}>.
Constructor: (container: HTMLElement)
Методы:
setDescription(text: string) — установить текст подтверждения заказа;
onClose(handler: () => void) — обработчик закрытия модального окна;
render() — вернуть контейнер компонента.








